const express = require('express');
const fetch = require('node-fetch');
// Fallback: garantir que .env seja carregado caso o servidor tenha sido iniciado sem carregar dotenv
try {
    if (!process.env.GEMINI_API_KEY) {
        require('dotenv').config({ path: require('path').join(__dirname, '..', '.env') });
        console.log('[GEMINI ROUTE] dotenv carregado localmente. Chave presente agora?', process.env.GEMINI_API_KEY ? 'SIM' : 'N√ÉO');
    }
} catch (e) {
    console.warn('[GEMINI ROUTE] Falha ao carregar dotenv localmente:', e?.message);
}
const router = express.Router();
const { autenticar } = require('../middleware/auth');

// Endpoint para an√°lise de c√≥digo com Gemini AI
router.post('/analyze', autenticar, async (req, res) => {
    console.log('\n==========================================');
    console.log('ü§ñ [GEMINI] Rota /analyze foi CHAMADA!');
    console.log('ü§ñ [GEMINI] User:', req.user?.username);
    console.log('ü§ñ [GEMINI] Body keys:', Object.keys(req.body));
    console.log('ü§ñ [GEMINI] Files recebidos:', req.body?.files?.length || 0);
    console.log('==========================================')

    try {
        const { files, missionContext } = req.body;

        if (!files || !Array.isArray(files)) {
            console.log('‚ùå [GEMINI] Files inv√°lidos:', files);
            return res.status(400).json({
                success: false,
                error: 'Arquivos s√£o obrigat√≥rios para an√°lise'
            });
        }

        // Verificar se a API key est√° configurada
        const geminiApiKey = process.env.GEMINI_API_KEY;
        console.log('\nüîç Verificando API Key do Gemini...');
        console.log('   - API Key presente:', geminiApiKey ? '‚úÖ SIM' : '‚ùå N√ÉO');
        console.log('   - Tamanho da chave:', geminiApiKey ? geminiApiKey.length : 0);
        console.log('   - Primeiros 15 caracteres:', geminiApiKey ? geminiApiKey.substring(0, 15) + '...' : 'N/A');
        console.log('   - √öltimos 10 caracteres:', geminiApiKey ? '...' + geminiApiKey.substring(geminiApiKey.length - 10) : 'N/A');

        if (!geminiApiKey || geminiApiKey.trim() === '') {
            console.log('‚ö†Ô∏è AVISO: API Key do Gemini n√£o configurada. Usando feedback de demonstra√ß√£o.');
            // Retornar indica√ß√£o de que deve usar fallback ao inv√©s de erro
            return res.status(503).json({
                success: false,
                error: 'API_KEY_NOT_CONFIGURED',
                message: 'Chave da API Gemini n√£o configurada. Configure em backend/.env para usar an√°lise com IA.',
                useFallback: true
            });
        }

        console.log('‚úÖ API Key configurada! Fazendo chamada ao Gemini...');

        // Construir o prompt para an√°lise
        const prompt = buildAnalysisPrompt(files, missionContext);

        // Tentar m√∫ltiplos modelos compat√≠veis com a API v1, na ordem de prefer√™ncia
        // Modelos mais recentes primeiro (Gemini 2.x), depois fallback para 1.5
        const modelCandidates = [
            'gemini-2.5-flash',      // Mais r√°pido e eficiente (2025)
            'gemini-2.0-flash',      // Alternativa r√°pida
            'gemini-2.5-pro',        // Mais avan√ßado
            'gemini-1.5-flash',      // Fallback para contas antigas
            'gemini-1.5-pro',        // Fallback para contas antigas
            'gemini-pro'             // Fallback final
        ];

        let lastErrText = '';
        let tried404 = false;
        console.log('\nüìã Tentando modelos:', modelCandidates.join(', '));

        for (const model of modelCandidates) {
            const url = `https://generativelanguage.googleapis.com/v1/models/${model}:generateContent?key=${geminiApiKey}`;
            console.log(`\nüöÄ [TENTATIVA] Modelo: ${model}`);
            console.log(`   URL: ${url.replace(geminiApiKey, 'API_KEY_OCULTA')}`);

            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{ role: 'user', parts: [{ text: prompt }] }],
                    generationConfig: {
                        temperature: 0.7,
                        topK: 40,
                        topP: 0.95,
                        maxOutputTokens: 2048,
                    }
                })
            });

            console.log(`üì° [RESPOSTA] Status: ${response.status} ${response.statusText}`);

            if (!response.ok) {
                const errorText = await response.text();
                lastErrText = errorText;
                console.error(`\n‚ùå [ERRO] Modelo ${model} falhou:`);
                console.error(`   Status: ${response.status}`);
                console.error(`   Resposta: ${safeTruncate(errorText, 500)}`);
                // Se for 404 (modelo n√£o encontrado/n√£o habilitado), tenta o pr√≥ximo
                if (response.status === 404) {
                    console.warn(`   ‚ö†Ô∏è Modelo ${model} n√£o dispon√≠vel (404), tentando pr√≥ximo...`);
                    tried404 = true;
                    continue;
                }
                // Para outros erros (quota, auth, etc), devolve erro imediatamente
                return res.status(response.status).json({
                    success: false,
                    error: 'GEMINI_API_ERROR',
                    status: response.status,
                    statusText: response.statusText,
                    details: safeTruncate(errorText),
                    timestamp: new Date().toISOString()
                });
            }

            const data = await response.json();

            if (!data.candidates || !data.candidates[0]) {
                console.error(`‚ùå Resposta inv√°lida para ${model}:`, JSON.stringify(data).slice(0, 500));
                continue;
            }

            const feedback = extractFeedbackText(data);
            console.log(`\nüìù [SUCESSO] Texto extra√≠do do modelo ${model}:`);
            console.log(`   Tamanho: ${feedback ? feedback.length : 0} caracteres`);
            console.log(`   Preview: ${feedback ? feedback.substring(0, 100) + '...' : 'vazio'}`);

            if (!feedback) {
                console.error(`‚ùå Conte√∫do vazio em ${model}:`, JSON.stringify(data).slice(0, 500));
                continue;
            }

            console.log('‚úÖ [GEMINI] An√°lise conclu√≠da com sucesso!');
            console.log('==========================================\n');
            return res.json({
                success: true,
                model,
                feedback,
                timestamp: new Date().toISOString()
            });
        }

        // Se ambos retornaram 404, vamos consultar a lista de modelos dispon√≠veis e tentar um suportado
        if (tried404) {
            console.log('üîé Consultando modelos dispon√≠veis via ListModels...');
            const listUrl = `https://generativelanguage.googleapis.com/v1/models?key=${geminiApiKey}`;
            try {
                const listResp = await fetch(listUrl, { method: 'GET' });
                if (!listResp.ok) {
                    const t = await listResp.text();
                    console.error('‚ùå Falha ao listar modelos:', t);
                } else {
                    const list = await listResp.json();
                    const models = Array.isArray(list.models) ? list.models : [];
                    console.log(`üìã Modelos retornados (${models.length}):`, models.slice(0, 5).map(m => ({ name: m.name, supported: m.supportedGenerationMethods })).slice(0, 5));

                    // Escolher um modelo que suporte generateContent
                    const preferredOrder = ['gemini-1.5-flash', 'gemini-1.5-pro', 'gemini-1.0-pro', 'gemini-pro'];
                    // m.name vem como 'models/gemini-1.5-flash'
                    const normalize = (n) => n?.replace(/^models\//, '');
                    const findCandidate = () => {
                        for (const pref of preferredOrder) {
                            const hit = models.find(m => normalize(m.name) === pref && m.supportedGenerationMethods?.includes('generateContent'));
                            if (hit) return normalize(hit.name);
                        }
                        // fallback: qualquer um que suporte generateContent
                        const any = models.find(m => m.supportedGenerationMethods?.includes('generateContent'));
                        return any ? normalize(any.name) : null;
                    };

                    const dynamicModel = findCandidate();
                    if (dynamicModel) {
                        console.log(`üß≠ Tentando modelo din√¢mico: ${dynamicModel}`);
                        const dynUrl = `https://generativelanguage.googleapis.com/v1/models/${dynamicModel}:generateContent?key=${geminiApiKey}`;
                        const dynResp = await fetch(dynUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ role: 'user', parts: [{ text: prompt }] }],
                                generationConfig: { temperature: 0.7, topK: 40, topP: 0.95, maxOutputTokens: 2048 }
                            })
                        });
                        console.log('üì° Resposta do Gemini (din√¢mico):', dynResp.status, dynResp.statusText, `(${dynamicModel})`);
                        if (dynResp.ok) {
                            const data = await dynResp.json();
                            const feedback = extractFeedbackText(data);
                            console.log(`üìù Texto extra√≠do (din√¢mico ${dynamicModel}):`, feedback ? `${feedback.length} chars` : 'vazio');
                            if (feedback) {
                                return res.json({ success: true, model: dynamicModel, feedback, timestamp: new Date().toISOString() });
                            }
                        } else {
                            const t = await dynResp.text();
                            lastErrText = t;
                            console.error('‚ùå Modelo din√¢mico falhou:', t);
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Nenhum modelo com generateContent encontrado na conta.');
                    }
                }
            } catch (e) {
                console.error('‚ùå Erro ao consultar modelos:', e);
            }
        }

        // Se chegou aqui, nenhum modelo funcionou -> habilita fallback no frontend
        return res.status(503).json({
            success: false,
            error: 'MODEL_NOT_AVAILABLE',
            message: 'Nenhum modelo Gemini compat√≠vel encontrado para esta chave. Verifique permiss√µes/limites da conta no Google AI Studio.',
            lastErrText: safeTruncate(lastErrText),
            useFallback: true,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('Erro ao analisar c√≥digo com Gemini:', error);
        res.status(500).json({
            success: false,
            error: error.message || 'Erro interno do servidor',
            timestamp: new Date().toISOString()
        });
    }
});

/**
 * Constr√≥i o prompt para an√°lise do Gemini
 */
function buildAnalysisPrompt(files, missionContext) {
    const mission = missionContext?.title || 'Miss√£o n√£o especificada';
    const description = missionContext?.description || '';

    let prompt = `
# An√°lise de Submiss√£o de C√≥digo - Sistema Educacional RPG

## Contexto da Miss√£o
**T√≠tulo:** ${mission}
**Descri√ß√£o:** ${description}

## Arquivos Submetidos
`;

    files.forEach((file, index) => {
        prompt += `
### Arquivo ${index + 1}: ${file.name}
**Tipo:** ${file.type || 'text'}
**Tamanho:** ${file.size || 0} bytes

\`\`\`${file.type || 'text'}
${file.content || '[Conte√∫do n√£o dispon√≠vel]'}
\`\`\`

`;
    });

    prompt += `
## Tarefa de An√°lise

Por favor, analise os arquivos submetidos e forne√ßa um feedback educacional detalhado seguindo esta estrutura:

### üìä **Pontua√ß√£o Geral**: [0-100]

### ‚úÖ **Pontos Positivos**
- Liste os aspectos bem implementados
- Destaque boas pr√°ticas de programa√ß√£o
- Reconhe√ßa solu√ß√µes criativas

### ‚ö†Ô∏è **√Åreas de Melhoria**
- Identifique problemas no c√≥digo
- Sugira melhorias espec√≠ficas
- Aponte erros de sintaxe ou l√≥gica

### üí° **Sugest√µes Detalhadas**
- Forne√ßa dicas pr√°ticas para melhorar
- Sugira recursos de aprendizado
- Indique pr√≥ximos passos

### üéØ **Cumprimento dos Objetivos**
- Avalie se a submiss√£o atende aos requisitos da miss√£o
- Identifique objetivos alcan√ßados e n√£o alcan√ßados

### üìö **Recursos Recomendados**
- Sugira materiais de estudo
- Indique documenta√ß√µes relevantes
- Recomende exerc√≠cios complementares

**Importante:** 
- Use linguagem encorajadora e educativa
- Seja espec√≠fico nas sugest√µes
- Foque no aprendizado do aluno
- Use emojis para tornar o feedback mais visual e engajante
`;

    return prompt;
}

module.exports = router;

// Evita estourar log/JSON com mensagens enormes
function safeTruncate(text, max = 1200) {
    if (!text) return text;
    return text.length > max ? text.slice(0, max) + '...<truncated>' : text;
}

// Extrai texto dos candidatos do Gemini unificando diferentes formatos
function extractFeedbackText(data) {
    try {
        if (!data || !Array.isArray(data.candidates) || data.candidates.length === 0) return '';
        const cand = data.candidates[0];
        // 1) parts[].text concatenado
        const parts = cand?.content?.parts;
        if (Array.isArray(parts)) {
            const joined = parts.map(p => p?.text).filter(Boolean).join('\n');
            if (joined && joined.trim().length > 0) return joined.trim();
        }
        // 2) output_text (algumas libs exp√µem assim)
        if (cand.output_text && String(cand.output_text).trim().length > 0) {
            return String(cand.output_text).trim();
        }
        // 3) candidates[0].content como string direta (fallback raro)
        if (typeof cand.content === 'string' && cand.content.trim().length > 0) {
            return cand.content.trim();
        }
        return '';
    } catch (_) {
        return '';
    }
}
